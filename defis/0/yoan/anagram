#!/usr/bin/env ruby

# def anagrams(str)
# str.chars.permutation.uniq.map(&:join).reject { |s| s == str }
# end

class String
  def anagrams
    chars.permutation.uniq.map(&:join).reject { |s| s == self }
  end
  
  def frequencies
    each_char.with_object(Hash.new(0)) { |letter, freq| freq[letter] += 1}
  end
end

dico = File.readlines(ARGV.shift).map(&:chomp)
words = ARGV

# ===== Méthode 4
#
# Transforming the list of words into a trie
#
# To comment and explain 
#
# improves by go through the trie once for all the words
#
#
# improves by creating the trie while reading the file (esay to do)


def make_trie(words)
  trie = Hash.new()
  words.each do |w|
    d = trie
    w.each_char do |c|
      d[c] = d[c].nil? ? {} : d[c]
      d = d[c]
    end
    d["\0"] = {}
  end
  trie
end

def in_trie(trie, word)
  d = trie
  word.each_char do |l|
    return false unless d.keys.include?(l)
    d = d[l]
  end
  return true
end

def anagram(trie, word)
  result = []
  
  def aux(frequencies, path, root, length, result, word)
    if length == path.length && root.has_key?("\0")
      ret = path.join
      result << ret if ret != word
    else
      root.each do |letter, d|
        if frequencies[letter] > 0
          path << letter
          frequencies[letter] -= 1
          aux(frequencies, path, d, length, result, word)
          path.pop()
          frequencies[letter] += 1
        end
      end
    end
  end
  aux(word.frequencies, [], trie, word.length, result, word)
  result
end

trie = make_trie(dico)

words.each do |w|
  puts "#{w}:"
  puts anagram(trie, w)
end


# ===== Méthode 3
#
# TODO 
#
# Hash all the words and collect the ones which has the same hash value.
# - Find a way to have the same hash iff anagrams.
# - idea : map each character to a prime number, the value of a string is the product
# of its character. We have f(s1) = f(s2) iff s1 equivalent to s2 (anagram)
#
# Warning : too big number with long string. Maybe try to associate short prime
# numbers to frequent characters.


# ======

# Méthode 2

# sorted_dico = dico.each_with_index.map { |w, i| [i, w.chars.sort.join] }.sort_by {|e| e[1]}
# sorted_words = words.each_with_index.map { |w, i| [i, w.chars.sort.join] }.sort_by {|e| e[1]}

# i = 0
# sorted_words.each do |j, w|
  # puts "#{words[j]}:"
  # while sorted_dico[i][1] < w
    # i += 1
  # end
  # while sorted_dico[i][1] == w
    # puts dico[sorted_dico[i][0]] if  dico[sorted_dico[i][0]] != words[j]
    # i += 1
  # end
 # end

# ======

# words.each do |w|
  # list = (w.anagrams & words_list).sort
  # puts "#{w}:"
  # puts list
  # puts
# end

